/*++

Copyright (c) 2017 Trent Nelson <trent@trent.me>

Module Name:

    DebugEngineOutput.c

Abstract:

    This module implements functionality related to the DEBUG_ENGINE_OUTPUT
    structure.

--*/

#include "stdafx.h"

_Use_decl_annotations_
BOOL
InitializeDebugEngineOutput(
    PDEBUG_ENGINE_OUTPUT Output,
    PDEBUG_ENGINE_SESSION DebugEngineSession,
    PALLOCATOR Allocator,
    PALLOCATOR LineAllocator,
    PALLOCATOR TextAllocator,
    PALLOCATOR CustomStructureAllocator,
    PALLOCATOR CustomStructureSecondaryAllocator,
    PDEBUG_ENGINE_PARTIAL_OUTPUT_CALLBACK LineOutputCallback,
    PDEBUG_ENGINE_PARTIAL_OUTPUT_CALLBACK PartialOutputCallback,
    PDEBUG_ENGINE_OUTPUT_COMPLETE_CALLBACK OutputCompleteCallback,
    PVOID Context,
    PRTL_PATH ModulePath
    )
/*++

Routine Description:

    This routine initializes a DEBUG_ENGINE_OUTPUT structure.  It is called
    prior to preparing and executing a command.  It serves as the mechanism
    to persist and encapsulate state when processing multiple output callbacks
    from the debug engine for a given command.

Arguments:

    Output - Supplies a pointer to the DEBUG_ENGINE_OUTPUT structure to
        initialize.  The SizeOfStruct field must be set to the correct size
        (i.e. equal to sizeof(DEBUG_ENGINE_OUTPUT)) otherwise an error will
        be returned.

    DebugEngineSession - Supplies a pointer to the debug engine session to
        associate with this output.

    Allocator - Supplies a pointer to an ALLOCATOR structure that the debug
        engine can use for temporary allocations (such as string buffer
        allocation when constructing dynamic commands).

    LineAllocator - Supplies a pointer to an ALLOCATOR structure to use for
        allocating STRING structures that are wired up to point to each line
        in the command's output.  The resulting line is accessible via the
        SavedLine field of the DEBUG_ENGINE_OUTPUT structure.

    TextAllocator - Supplies a pointer to an ALLOCATOR structure that will be
        used to allocate memory for the actual text/char content of the line.
        This buffer will be pointed to by the SavedLine->Buffer field of the
        DEBUG_ENGINE_OUTPUT structure.

    CustomStructureAllocator - Supplies a pointer to an ALLOCATOR structure that
        will be used to allocate memory for the custom structure associated with
        the given command's output, e.g. the ExamineSymbols() command will use
        the DEBUG_ENGINE_EXAMINED_SYMBOL structure to capture parsed raw line
        output.

    CustomStructureSecondaryAllocator - Supplies a pointer to an ALLOCATOR
        structure that will be used to allocate secondary memory in support of
        the custom structure's persistence.  E.g. if a custom structure has
        embedded dynamic structures (a linked list or array), this allocator
        will be used to allocate the memory.

    LineOutputCallback - Supplies a pointer to a callback that will be invoked
        one or more times for each line generated by the debug engine.

    PartialOutputCallback - Supplies a pointer to a callback that will be
        invoked one or more times as the debug engine generates output.  This
        output will be raw and unstructured.

    OutputCompleteCallback - Supplies a pointer to a callback that will be
        invoked once after a command has finished executing.

    Context - Optionally supplies an opaque context pointer that will be
        stored in the DEBUG_ENGINE_OUTPUT structure.

    ModulePath - Optionally supplies a pointer to an RTL_PATH structure that
        represents the module associated with a given command, if applicable.

Return Value:

    TRUE on Success, FALSE if an error occurred.

--*/
{
    //
    // Validate size.
    //

    if (Output->SizeOfStruct != sizeof(*Output)) {
        return FALSE;
    }

    //
    // Clear the entire structure.
    //

    SecureZeroMemory(Output, sizeof(*Output));

    //
    // Initialize fields.
    //

    Output->SizeOfStruct = sizeof(*Output);
    Output->Session = DebugEngineSession;
    Output->Allocator = Allocator;
    Output->LineAllocator = LineAllocator;
    Output->TextAllocator = TextAllocator;
    Output->CustomStructureAllocator = CustomStructureAllocator;
    Output->CustomStructureSecondaryAllocator = (
        CustomStructureSecondaryAllocator
    );
    Output->LineOutputCallback = LineOutputCallback;
    Output->PartialOutputCallback = PartialOutputCallback;
    Output->OutputCompleteCallback = OutputCompleteCallback;
    Output->SaveOutputLine = DebugEngineSaveOutputLine;

    if (Output->SaveOutputLine) {
        Output->Flags.DispatchOutputLineCallbacks = TRUE;
    }

    InitializeListHead(&Output->SavedLinesListHead);
    InitializeListHead(&Output->PartialLinesListHead);

    //
    // Set the optional fields if applicable.
    //

    if (ARGUMENT_PRESENT(Context)) {
        Output->Context = Context;
    }

    if (ARGUMENT_PRESENT(ModulePath)) {
        Output->ModulePath = ModulePath;
    }

    Output->State.Initialized = TRUE;

    //
    // Return success.
    //

    return TRUE;
}

_Use_decl_annotations_
BOOL
InitializeDebugEngineOutputSimple(
    PDEBUG_ENGINE_OUTPUT Output,
    PDEBUG_ENGINE_SESSION Session
    )
/*++

Routine Description:

    This routine is a simplified version of InitializeDebugEngineOutput();
    the allocator defaults to DebugEngineSession->Rtl->Allocator, and the
    default debug stream line output callback and dummy partial and output
    complete callbacks are used.  No context or module name is set.

Arguments:

    Output - Supplies a pointer to the DEBUG_ENGINE_OUTPUT structure to
        initialize.  The SizeOfStruct field must be set to the correct size
        (i.e. equal to sizeof(DEBUG_ENGINE_OUTPUT)) otherwise an error will
        be returned.

    Session - Supplies a pointer to the debug engine session to associate with
        this output.

Return Value:

    TRUE on Success, FALSE if an error occurred.

--*/
{

    return InitializeDebugEngineOutput(Output,
                                       Session,
                                       Session->Allocator,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       DebugStreamLineOutputCallback,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);
}

_Use_decl_annotations_
HRESULT
STDAPICALLTYPE
DebugEngineOutputCallback(
    PDEBUG_ENGINE DebugEngine,
    DEBUG_OUTPUT_MASK OutputMask,
    PCSTR Text
    )
/*++

Routine Description:

    This routine is our main debug output callback that is called directly by
    the debugger.  It is responsible for processing text output based on the
    current DEBUG_ENGINE_OUTPUT structure associated with the engine.  This
    structure is used to capture both the command and the resulting text output
    from the debugger.

    The debugger invokes this callback in a somewhat unpredictable fashion in
    that we can't rely on getting nicely line-delineated chunks of text upon
    invocation.  Therefore, if a caller has requested line-oriented output, we
    need to buffer the text and do line delineation ourselves, which occupies
    the vast majority of this routine's logic.

Arguments:

    Engine - Supplies a pointer to the DEBUG_ENGINE to use.

    OutputMask - Supplies the output mask for this chunk of text.

    Text - Supplies a NUL-terminated ANSI string of varying length that contains
        output from the debugger after a command has been executed.

Return Value:

    S_OK on success, E_FAIL on error.

--*/
{
    PRTL Rtl;
    ULONG Index;
    BOOL Success;
    PCHAR Dest;
    PSTRING Line;
    PSTRING Chunk;
    STRING NewLine;
    HRESULT Result;
    ULONG BitIndex;
    ULONG LastBitIndex;
    ULONG NumberOfLines;
    PSTRING PartialLine;
    STRING TrailingChunk;
    PALLOCATOR Allocator;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEntry;
    HANDLE HeapHandle;
    PDEBUG_ENGINE_OUTPUT Output;
    ULONG_INTEGER TextSizeInBytes;
    ULONG_INTEGER AllocSizeInBytes;
    ULONG_INTEGER NewLineLengthInBytes;
    LONG_INTEGER TrailingBytes = { 0 };
    PRTL_FIND_SET_BITS FindSetBits;
    PLINKED_LINE LinkedPartialLine;

    //
    // Reserve a 256 byte (2048 bit/char) stack-allocated bitmap buffer for
    // the line ending bitmap.
    //

    CHAR StackBitmapBuffer[256];
    RTL_BITMAP Bitmap = { 256 << 3, (PULONG)&StackBitmapBuffer };
    PRTL_BITMAP BitmapPointer = &Bitmap;
    PRTL_BITMAP LineEndings;

    //
    // Calculate the size in bytes of the incoming text.
    //

    TextSizeInBytes.LongPart = (LONG)strlen(Text);

    //
    // Sanity check it's not over MAX_USHORT (which would prevent it from
    // fitting in our STRING structure).
    //

    if (TextSizeInBytes.HighPart) {
        __debugbreak();
        goto Error;
    }

    //
    // If this isn't normal output, just print it to the debug stream and
    // return.  (We should probably attempt to grok the warning/error messages
    // in the future -- like those involving symbol loading issues.)
    //

    if (!OutputMask.Normal) {
        if (Text) {
            PrintAsciiToDebugStream((PSTR)Text, TextSizeInBytes.LowPart);
        }
        return S_OK;
    }

    //
    // Resolve the Output structure and set our state to indicate we're in a
    // partial callback.
    //

    Output = DebugEngine->CurrentOutput;
    Output->State.InPartialOutputCallback = TRUE;

    //
    // Do we ever get empty lines?
    //

    if (!TextSizeInBytes.LowPart) {
        __debugbreak();
        goto Error;
    }

    //
    // Capture the details about this chunk.
    //

    Chunk = &Output->Chunk;
    Chunk->Length = TextSizeInBytes.LowPart;
    Chunk->MaximumLength = TextSizeInBytes.LowPart;
    Chunk->Buffer = (PSTR)Text;

    if (TextSizeInBytes.LongPart > Output->LargestChunkSizeInBytes) {

        //
        // This new chunk is the largest we've seen.  Make a note.
        //

        Output->LargestChunkSizeInBytes = TextSizeInBytes.LongPart;
    }

    //
    // Mark these bytes as trailing until proven otherwise.
    //

    TrailingBytes.LowPart = TextSizeInBytes.LowPart;

    //
    // Update our partial callback counter and totals counters.
    //

    Output->NumberOfPartialCallbacks++;
    Output->TotalBufferLengthInChars += TextSizeInBytes.LowPart;
    Output->TotalBufferSizeInBytes += TextSizeInBytes.LowPart;

    //
    // Invoke the relevant callbacks based on the caller's output flags.
    //

    Result = S_OK;

    if (Output->Flags.EnablePartialOutputCallbacks) {
        Success = Output->PartialOutputCallback(Output);
        if (!Success) {
            goto Error;
        }
    }

    if (!Output->Flags.DispatchOutputLineCallbacks) {
        goto End;
    }

    //
    // The caller wants line-oriented callbacks.
    //

    //
    // Initialize aliases.
    //

    Rtl = DebugEngine->Rtl;
    FindSetBits = Rtl->RtlFindSetBits;
    Allocator = Output->Allocator;
    HeapHandle = Output->Allocator->HeapHandle;

    //
    // Create a bitmap of line endings.
    //

    Success = Rtl->CreateBitmapIndexForString(Rtl,
                                              Chunk,
                                              '\n',
                                              &HeapHandle,
                                              &BitmapPointer,
                                              FALSE,
                                              NULL);

    if (!Success) {
        goto Error;
    }

    //
    // Determine the number of lines in the output based on the number of
    // bits in the bitmap.
    //

    NumberOfLines = Rtl->RtlNumberOfSetBits(BitmapPointer);
    if (NumberOfLines == 0) {

        //
        // There were no lines, so add the entire chunk as a partial line.
        //

        goto AddPartialLine;
    }

    //
    // We have at least one line to process if we reach this point.  Initialize
    // the line-oriented local variables and then extract the first line.
    //

    BitIndex = 0;
    LastBitIndex = 0;
    Line = &Output->Line;
    LineEndings = BitmapPointer;

    //
    // Extract the first line.
    //

    BitIndex = FindSetBits(LineEndings, 1, LastBitIndex);
    if (BitIndex == BITS_NOT_FOUND || BitIndex < LastBitIndex) {

        //
        // We shouldn't ever hit this on the first line.
        //

        __debugbreak();
    }

    //
    // Fill in the first line details.
    //

    Line->Length = (USHORT)(BitIndex - (LastBitIndex-1));
    Line->MaximumLength = Line->Length;
    Line->Buffer = (PCHAR)(Text + LastBitIndex);

    //
    // Update the last bit index.
    //

    LastBitIndex = BitIndex + 1;

    //
    // Decrement the trailing bytes counter.
    //

    TrailingBytes.LongPart -= Line->Length;

    //
    // If there are no partial lines recorded, dispatch this line output
    // callback then jump to the processing of remaining lines.
    //

    if (!Output->NumberOfPartialLines) {
        Success = DispatchOutputLineCallbacks(Output);
        if (!Success) {
            goto Error;
        }
        goto ProcessLines;
    }

    //
    // Calculate the size of all the partial lines, allocate a new buffer,
    // copy all of them over, freeing the strings + buffers as we go, call
    // the caller's line output callback with the final line, then free it
    // too.
    //

    NewLineLengthInBytes.LongPart = 0;

    ListHead = &Output->PartialLinesListHead;

    FOR_EACH_LIST_ENTRY(ListHead, ListEntry) {

        LinkedPartialLine = CONTAINING_RECORD(ListEntry,
                                              LINKED_LINE,
                                              ListEntry);

        NewLineLengthInBytes.LongPart += LinkedPartialLine->Length;
    }

    //
    // Add the length of this most recent line.
    //

    NewLineLengthInBytes.LongPart += Line->Length;

    //
    // Align up to a pointer boundary.
    //

    AllocSizeInBytes.LongPart = ALIGN_UP_POINTER(NewLineLengthInBytes.LongPart);

    //
    // Sanity check the size doesn't exceed MAX_USHORT.
    //

    if (AllocSizeInBytes.HighPart) {
        __debugbreak();
        goto Error;
    }

    //
    // Attempt to allocate a buffer.
    //

    NewLine.Buffer = (PCHAR)(
        Allocator->Calloc(
            Allocator->Context,
            1,
            AllocSizeInBytes.LongPart
        )
    );

    if (!NewLine.Buffer) {
        goto Error;
    }

    //
    // Allocation succeeded, copy each partial string, then free it.
    //

    Dest = NewLine.Buffer;

    while (!IsListEmpty(ListHead)) {

        ListEntry = RemoveHeadList(ListHead);

        LinkedPartialLine = CONTAINING_RECORD(ListEntry,
                                              LINKED_LINE,
                                              ListEntry);

        PartialLine = &LinkedPartialLine->String;
        __movsb(Dest, PartialLine->Buffer, PartialLine->Length);
        Dest += PartialLine->Length;
        Allocator->Free(Allocator->Context, LinkedPartialLine);
        Output->NumberOfPartialLines--;
    }

    //
    // Sanity check invariants: number of partial lines should be 0 and our
    // list head should be empty.
    //

    if (Output->NumberOfPartialLines) {
        __debugbreak();
    }

    if (!IsListEmpty(ListHead)) {
        __debugbreak();
    }

    //
    // Copy the contents of the latest line.
    //

    __movsb(Dest, Line->Buffer, Line->Length);

    //
    // Update lengths and invoke the caller's line output callback.
    //

    NewLine.Length = NewLineLengthInBytes.LowPart;
    NewLine.MaximumLength = AllocSizeInBytes.LowPart;

    //
    // Update the line in the output structure.
    //

    Line = &Output->Line;
    Line->Length = NewLine.Length;
    Line->MaximumLength = NewLine.MaximumLength;
    Line->Buffer = NewLine.Buffer;

    Success = DispatchOutputLineCallbacks(Output);

    //
    // Free the temporary string buffer we allocated.
    //

    Allocator->Free(Allocator->Context, Line->Buffer);

    Line->Length = 0;
    Line->MaximumLength = 0;
    Line->Buffer = NULL;

    if (!Success) {
        goto Error;
    }

    //
    // Intentional follow-on to ProcessLines.
    //

ProcessLines:

    //
    // Enumerate the line ending bitmap and isolate each line.  Note that
    // the Index starts at 1 as we've already processed the first line
    // ending.
    //

    for (Index = 1; Index < NumberOfLines; Index++) {
        BitIndex = FindSetBits(LineEndings, 1, LastBitIndex);
        if (BitIndex == BITS_NOT_FOUND || BitIndex < LastBitIndex) {
            break;
        }
        Line->Length = (USHORT)(BitIndex - (LastBitIndex-1));
        Line->MaximumLength = Line->Length;
        Line->Buffer = (PCHAR)(Text + LastBitIndex);
        LastBitIndex = BitIndex + 1;

        //
        // Invoke the caller's line output callback.
        //

        if (!DispatchOutputLineCallbacks(Output)) {
            goto Error;
        }

        //
        // Decrement the trailing bytes counter.
        //

        TrailingBytes.LongPart -= Line->Length;
    }

AddPartialLine:

    //
    // Invariant check: trailing bytes should be >= 0 and under MAX_USHORT.
    //

    if (TrailingBytes.LongPart < 0) {
        __debugbreak();
        goto Error;
    }

    if (TrailingBytes.HighPart) {
        __debugbreak();
        goto Error;
    }

    if (TrailingBytes.LowPart == 0) {

        //
        // There were no trailing bytes, so no more needs to be done.
        //

        goto End;
    }

    TrailingChunk.Length = TrailingBytes.LowPart;
    TrailingChunk.MaximumLength = TrailingBytes.LowPart;

    //
    // Calculate the new buffer offset by taking the original text buffer,
    // adding the text size in bytes, then subtracting the trailing bytes
    // count.
    //

    TrailingChunk.Buffer = (PSTR)Text + TextSizeInBytes.LowPart;
    TrailingChunk.Buffer -= TrailingBytes.LowPart;

    if (NumberOfLines && Line->Buffer) {
        PCHAR ExpectedBuffer;

        //
        // Invariant check: if we processed at least one line, the trailing
        // chunk's buffer should match the byte after the last line's buffer,
        // and the last byte should be a line feed character.
        //

        ExpectedBuffer = Line->Buffer + Line->Length;
        if (*(ExpectedBuffer - 1) != '\n') {
            __debugbreak();
            goto Error;
        }

        if (TrailingChunk.Buffer != ExpectedBuffer) {
            __debugbreak();
            goto Error;
        }
    }

    //
    // All the invariant checks pass, continue allocating the partial line
    // structure.
    //

    AllocSizeInBytes.LongPart = (

        //
        // Account for the size of the STRING structure.
        //

        sizeof(LINKED_LINE) +

        //
        // Account for the actual backing string buffer.
        //

        TrailingChunk.Length

    );

    //
    // Sanity check we're under MAX_USHORT.
    //

    if (AllocSizeInBytes.HighPart) {
        __debugbreak();
        goto Error;
    }

    //
    // Attempt to allocate space.
    //

    LinkedPartialLine = (PLINKED_LINE)(
        Allocator->Calloc(
            Allocator->Context,
            1,
            AllocSizeInBytes.LongPart
        )
    );

    if (!LinkedPartialLine) {
        goto Error;
    }

    //
    // Initialize the list entry.
    //

    InitializeListHead(&LinkedPartialLine->ListEntry);

    //
    // Initialize the Line pointer then carve out the buffer from the allocated
    // memory.
    //

    Line = &LinkedPartialLine->String;
    Line->Buffer = (PCHAR)(
        RtlOffsetToPointer(
            LinkedPartialLine,
            sizeof(LINKED_LINE)
        )
    );

    //
    // Set the lengths.
    //

    Line->Length = TrailingChunk.Length;
    Line->MaximumLength = TrailingChunk.Length;

    //
    // Copy the text over.
    //

    if (!CopyMemoryQuadwords(Line->Buffer,
                             (PCHAR)TrailingChunk.Buffer,
                             Line->Length)) {
        Allocator->Free(Allocator->Context, LinkedPartialLine);
        goto Error;
    }

    //
    // Append the linked line to the output list head and increment the
    // partial line counter.
    //

    AppendTailList(&Output->PartialLinesListHead,
                   &LinkedPartialLine->ListEntry);

    Output->NumberOfPartialLines++;

    goto End;

Error:
    Result = E_FAIL;

    //
    // Intentional follow-on to End.
    //

    __debugbreak();

End:

    //
    // Free the bitmap buffer if one was required for this line (unlikely).
    //

    if ((ULONG_PTR)Bitmap.Buffer != (ULONG_PTR)StackBitmapBuffer) {
        HeapFree(HeapHandle, 0, Bitmap.Buffer);
    }

    //
    // Update output state and return.
    //

    Output->State.InPartialOutputCallback = FALSE;
    return Result;
}

_Use_decl_annotations_
BOOL
DebugEngineSaveOutputLine(
    PDEBUG_ENGINE_OUTPUT Output
    )
/*++

Routine Description:

    This routine saves individual output lines from a debugger command's
    output using two allocators provided by the caller: LineAllocator and
    TextAllocator.

    The LineAllocator is used to allocate a LINKED_LINE structure, which is
    primed with the relevant lengths of the current line output.  TextAllocator
    is then used to allocate the buffer for the underlying string (char *) data,
    which the linked line's Buffer field is then pointed at.

    The newly-allocated linked line is then appended to the output's linked list
    head (Output->SavedLineListHead) and the number of saved lines counter is
    incremented.

    N.B. If a STATUS_IN_PAGE_ERROR occurs when manipulating the linked line,
         the routine returns FALSE and no attempt is made to free either the
         line or the text.

Arguments:

    Output - Supplies a pointer to the DEBUG_ENGINE_OUTPUT structure associated
        with the current command.

Return Value:

    TRUE on success, FALSE on error.

--*/
{
    PCHAR Text = NULL;
    PSTRING Line;
    PDEBUG_ENGINE Engine;
    PLINKED_LINE LinkedLine = NULL;
    PALLOCATOR LineAllocator;
    PALLOCATOR TextAllocator;
    PLARGE_INTEGER Timestamp;
    PDEBUG_ENGINE_SESSION Session;

    //
    // Initialize aliases.
    //

    Line = &Output->Line;
    Session = Output->Session;
    Engine = Session->Engine;
    LineAllocator = Output->LineAllocator;
    TextAllocator = Output->TextAllocator;
    Timestamp = &Output->Timestamp.CommandStart;

    //
    // Sanity check that the output's line is in a valid state before we start
    // allocating memory.
    //

    if (!Line->Length || !Line->Buffer) {
        __debugbreak();
        return FALSE;
    }

    //
    // Allocate the linked line structure.
    //

    LinkedLine = (PLINKED_LINE)(
        LineAllocator->CallocWithTimestamp(
            LineAllocator->Context,
            1,
            sizeof(*LinkedLine),
            Timestamp
        )
    );

    if (!LinkedLine) {
        return FALSE;
    }

    //
    // Allocation was successful, proceed with allocation of the text.
    //

    Text = (PCHAR)(
        TextAllocator->CallocWithTimestamp(
            TextAllocator->Context,
            1,
            Line->Length,
            Timestamp
        )
    );

    if (!Text) {
        LineAllocator->FreePointer(LineAllocator->Context, &LinkedLine);
        return FALSE;
    }

    //
    // The linked line and backing text structures have been allocated, any
    // errors after this point will be due to STATUS_IN_PAGE_ERRORS, which means
    // our allocators are backed by trace stores, and thus, there isn't any
    // point in attempting to free the allocations.
    //

    if (!CopyMemoryQuadwords(Text, Line->Buffer, Line->Length)) {
        return FALSE;
    }

    TRY_MAPPED_MEMORY_OP {

        //
        // Initialize the linked line with the line's details.
        //

        LinkedLine->Length = Line->Length;
        LinkedLine->MaximumLength = Line->Length;
        LinkedLine->Buffer = Text;

        //
        // Append it to the output's list of saved lines and adjust counters.
        //

        InitializeListHead(&LinkedLine->ListEntry);
        AppendTailList(&Output->SavedLinesListHead, &LinkedLine->ListEntry);
        Output->NumberOfSavedBytes += Line->Length;

        if (++Output->NumberOfSavedLines == 1) {
            Output->FirstSavedLineBuffer = Text;
            Output->FirstSavedLine = LinkedLine;

            Output->SavedLineAllocationState.Contiguous = TRUE;
            Output->SavedLineAllocationState.Discontiguous = FALSE;
            Output->SavedLineBufferAllocationState.Contiguous = TRUE;
            Output->SavedLineBufferAllocationState.Discontiguous = FALSE;

        } else {

            //
            // Check the contiguity of the new allocations.
            //

            BOOL Contiguous;
            PCSTR ExpectedEndBufferAddress;
            PCSTR ActualEndBufferAddress;
            PLINKED_LINE ExpectedEndLinkedLineAddress;
            PLINKED_LINE ActualEndLinkedLineAddress;

            //
            // If the buffers are already discontiguous, jump straight to the
            // linked line comparison.
            //

            if (Output->SavedLineBufferAllocationState.Discontiguous) {
                goto CompareLinkedLines;
            }

            ExpectedEndBufferAddress = (PCHAR)(
                RtlOffsetToPointer(
                    Output->FirstSavedLineBuffer,
                    Output->NumberOfSavedBytes
                )
            );

            ActualEndBufferAddress = (PCHAR)(
                RtlOffsetToPointer(
                    Text,
                    Line->Length
                )
            );

            Contiguous = (ExpectedEndBufferAddress == ActualEndBufferAddress);
            if (!Contiguous) {
                __debugbreak();
                Output->SavedLineBufferAllocationState.Contiguous = FALSE;
                Output->SavedLineBufferAllocationState.Discontiguous = TRUE;
                Output->FirstDiscontiguousBufferIndex = (
                    Output->NumberOfSavedLines - 1
                );
            }

            //
            // Intentional follow-on to CompareLinkedLines.
            //

CompareLinkedLines:

            //
            // If the linked lines are already discontiguous, we're done.
            //

            if (Output->SavedLineBufferAllocationState.Discontiguous) {
                goto End;
            }

            ExpectedEndLinkedLineAddress = (PLINKED_LINE)(
                RtlOffsetToPointer(
                    Output->FirstSavedLine,
                    Output->NumberOfSavedLines * sizeof(*LinkedLine)
                )
            );

            ActualEndLinkedLineAddress = (PLINKED_LINE)(
                RtlOffsetToPointer(
                    LinkedLine,
                    sizeof(*LinkedLine)
                )
            );

            Contiguous = (
                ExpectedEndLinkedLineAddress ==
                ActualEndLinkedLineAddress
            );

            if (!Contiguous) {
                __debugbreak();
                Output->SavedLineAllocationState.Contiguous = FALSE;
                Output->SavedLineAllocationState.Discontiguous = TRUE;
                Output->FirstDiscontiguousLineIndex = (
                    Output->NumberOfSavedLines - 1
                );
            }
        }

    } CATCH_STATUS_IN_PAGE_ERROR {
        return FALSE;
    }

End:
    return TRUE;
}

_Use_decl_annotations_
HRESULT
STDAPICALLTYPE
DebugEngineOutputCallback2(
    PDEBUG_ENGINE DebugEngine,
    DEBUG_OUTPUT_TYPE OutputType,
    DEBUG_OUTPUT_CALLBACK_FLAGS OutputFlags,
    ULONG64 Arg,
    PCWSTR IncomingText
    )
{
    return E_FAIL;
}

_Use_decl_annotations_
BOOL
DebugStreamLineOutputCallback(
    PDEBUG_ENGINE_OUTPUT Output
    )
{
    PrintStringToDebugStream(&Output->Line);
    return TRUE;
}

_Use_decl_annotations_
BOOL
DummyPartialOutputCallback(
    PDEBUG_ENGINE_OUTPUT Output
    )
{
    return TRUE;
}

_Use_decl_annotations_
BOOL
DummyOutputCompleteCallback(
    PDEBUG_ENGINE_OUTPUT Output
    )
{
    return TRUE;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :
